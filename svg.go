package purplecrayon

import (
  "fmt"
  "io"
)

type svg struct {
  writer io.Writer
  width float64
  height float64
  objectCounter uint64
}

func (svg *svg) nextReference() Reference {
  defer func() {
    svg.objectCounter++
  }()
  return Reference(fmt.Sprintf("pcobj-%d", svg.objectCounter))
}

type svgCanvas struct {
  svg *svg
}

func topLevelClose() Reference {
  return ""
}

// Creates a new canvas which draws to an svg via the given io.Writer
func NewSVGCanvas(width, height float64, writer io.Writer) (canvas *svgCanvas) {
  io.WriteString(writer, fmt.Sprintf(`<svg width="%f" height="%f"> <!--
  Generated by PurpleCrayon
-->`, width, height))

  root := &svg{
    writer: writer,
    width: width,
    height: height,
  }

  canvas = &svgCanvas{
    svg: root,
  }

  return
}

func (c *svgCanvas) Close() Reference {
  io.WriteString(c.svg.writer, `</svg>`)
  return Reference("")
}

func (s *svgCanvas) Width() float64 {
  return s.svg.width
}

func (s *svgCanvas) Height() float64 {
  return s.svg.height
}

func (s *svgCanvas) Rect() Rect {
  r := makeSvgRect(s.svg)
  return &r
}

func (s *svgCanvas) Cursor() Cursor {
  r := makeSvgCursor(s.svg)
  return r
}

type svgRect struct {
  svg *svg
  attrs map[string]string
  svgPaintable
  svgTransformable
}

func makeSvgRect(svg *svg) svgRect {
  return svgRect{
    svg: svg,
    attrs: make(map[string]string),
    svgPaintable: makeSvgPaintable(),
    svgTransformable: makeSvgTransformable(),
  }
}

func (s svgRect) TopLeft(p Point) {
  s.attrs["x"] = fmt.Sprintf("%f", p.X)
  s.attrs["y"] = fmt.Sprintf("%f", p.Y)
}

func (s svgRect) Width(w float64) {
  s.attrs["width"] = fmt.Sprintf("%f", w)
}

func (s svgRect) Height(h float64) {
  s.attrs["height"] = fmt.Sprintf("%f", h)
}

func (s svgRect) Close() Reference {
  w := s.svg.writer 
  io.WriteString(w, `<rect`)
  for k, v := range s.attrs {
    io.WriteString(w, fmt.Sprintf(` %s="%s"`, k, v))
  }

  for _, compiled := range s.svgPaintable.compile() {
    io.WriteString(w, " " + compiled)
  }

  for _, compiled := range s.svgTransformable.compile() {
    io.WriteString(w, " " + compiled)
  }
  io.WriteString(w, `/>`)

  return s.svg.nextReference()
}

type svgCursor struct {
  svg *svg
  moves []string
  svgTransformable
  svgPaintable
}

func makeSvgCursor(svg *svg) *svgCursor {
  return &svgCursor{
    svg: svg,
    svgTransformable: makeSvgTransformable(),
    svgPaintable: makeSvgPaintable(),
  }
}

func (s *svgCursor) MoveTo(p Point) {
  s.moves = append(s.moves, fmt.Sprintf("M %f %f", p.X, p.Y))
}

func (s *svgCursor) MoveToRel(p Point) {
  s.moves = append(s.moves, fmt.Sprintf("m %f %f", p.X, p.Y))
}

func (s *svgCursor) LineTo(p Point) {
  s.moves = append(s.moves, fmt.Sprintf("L %f %f", p.X, p.Y))
}

func (s *svgCursor) LineToRel(p Point) {
  s.moves = append(s.moves, fmt.Sprintf("l %f %f", p.X, p.Y))
}

func (s *svgCursor) QuadTo(p0, p1 Point) {
  s.moves = append(s.moves, fmt.Sprintf("Q %f %f %f %f", p0.X, p0.Y, p1.X, p1.Y))
}

func (s *svgCursor) QuadToRel(p0, p1 Point) {
  s.moves = append(s.moves, fmt.Sprintf("q %f %f %f %f", p0.X, p0.Y, p1.X, p1.Y))
}

func (s *svgCursor) Zip() {
  s.moves = append(s.moves, "z")
}

func (s *svgCursor) Close() Reference {
  w := s.svg.writer 
  io.WriteString(w, `<path d="`)
  for _, move := range s.moves {
    io.WriteString(w, " " + move)
  }
  io.WriteString(w, `"`)

  for _, compiled := range s.svgPaintable.compile() {
    io.WriteString(w, " " + compiled)
  }

  for _, compiled := range s.svgTransformable.compile() {
    io.WriteString(w, " " + compiled)
  }
  io.WriteString(w, `/>`)

  return s.svg.nextReference()
}

type svgTransformable struct {
  attrs map[string]string
}

func makeSvgTransformable() svgTransformable {
  return svgTransformable{
    attrs: make(map[string]string),
  }
}

func (s svgTransformable) Translate(p Point) {
  s.attrs["translate"] = fmt.Sprintf("translate(%f, %f)", p.X, p.Y)
}

func (s svgTransformable) Scale(scale float64) {
  s.attrs["scale"] = fmt.Sprintf("scale(%f)", scale)
}

func (s svgTransformable) Rotate(degrees float64) {
  s.attrs["rotate"] = fmt.Sprintf("rotate(%f)", degrees)
}

func (s svgTransformable) compile() []string {
  transform := ""
  for _, v := range s.attrs {
    transform += " " + v
  }
  return []string{fmt.Sprintf(`transform="%s"`, transform)}
}

type svgPaintable struct {
  attrs map[string]string
}

func makeSvgPaintable() svgPaintable {
  return svgPaintable{
    attrs: make(map[string]string),
  }
}

func (s svgPaintable) compile() []string {
  ret := make([]string, len(s.attrs))
  idx := 0
  for k, v := range s.attrs {
    ret[idx] = fmt.Sprintf(`%s="%s"`, k, v)
    idx++
  }
  return ret
}

func (s svgPaintable) FillTransparent() {
  s.attrs["fill"] = "none"
}

func (s svgPaintable) FillRGB(color RGB) {
  s.attrs["fill"] = color.compiled()
}

func (s svgPaintable) FillRGBA(color RGBA) {
  s.attrs["fill"] = color.compiled()
}

func (s svgPaintable) Fill(ref Reference) {
  s.attrs["fill"] = ref.compiled()
}

func (s svgPaintable) StrokeWidth(w float64) {
  s.attrs["stroke-width"] = fmt.Sprintf("%f", w)
}

func (s svgPaintable) StrokeRGB(color RGB) {
  s.attrs["stroke"] = color.compiled()
}

func (s svgPaintable) StrokeRGBA(color RGBA) {
  s.attrs["stroke"] = color.compiled()
}

func (s svgPaintable) StrokeTransparent() {
  s.attrs["stroke"] = "none"
}

func (s svgPaintable) Stroke(ref Reference) {
  s.attrs["stroke"] = ref.compiled()
}

func (color RGB) compiled() string {
  return fmt.Sprintf("rgb(%d, %d, %d)",
    color.R,
    color.G,
    color.B,
  )
}

func (color RGBA) compiled() string {
  return fmt.Sprintf("rgba(%d, %d, %d, %d)",
    color.R,
    color.G,
    color.B,
    color.A,
  )
}

func (r Reference) compiled() string {
  return fmt.Sprintf("url(#%s)", string(r))
}

